შესასწავლი თემები  : 

 Web APIs: როგორ უკავშირდება JS ბრაუზერის ფუნქციებს (getDisplayMedia და requestPictureInPicture).

Stream vs URL: რატომ ვიყენებთ srcObject-ს და არა src-ს (ცოცხალი ნაკადი vs ფაილი).

Asynchronous Logic: რატომ გვჭირდება await, როცა მომხმარებლისგან ნებართვას ველოდებით.

Cleanup: რატომ არის მნიშვნელოვანი ნაკადის გათიშვა (stop()), რომ არ დავხარჯოთ მომხმარებლის ბატარეა და პროცესორი.



––––კოდის წერა–––––––––––––––––––––––––––––––––––––––
1 - გავეცნოთ picture-in-picture  api –ს. 
– screen capture Api -  mdn
https://css-tricks.com/an-introduction-to-the-picture-in-picture-web-api/
https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API/Using_Screen_Capture
 - 

2.
html ის მომზადება სტილებით
video tag. controls height, width hidden
- ფონტის შემოტანა
–height - 100 vh
- ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
3 - js
1. მედია ნაკადის "დაჭერა" (Screen Capture API)
სანამ PiP რეჟიმს ჩავრთავთ, ჯერ ბრაუზერს უნდა ვთხოვოთ ნებართვა, რომ ჩვენი ეკრანის (ან კონკრეტული ფანჯრის) გამოსახულება "დაინახოს".

რა ხდება: შენ უნდა გამოიძახო მეთოდი, რომელიც მომხმარებელს ამოუგდებს ფანჯარას: "რომელი ეკრანის გაზიარება გსურთ?".
navigator.mediaDevices.getDisplayMedia
შედეგი: ბრაუზერი გიბრუნებს მონაცემთა ნაკადს (Stream). არა ტექსტურ მისამართს !  არამედ ცოცხალ ვიდეო ნაკადს. ამ ნაკადს JavaScript-ში MediaStream ობიექტი ჰქვია.
 ეს დაბრუნებული ინფორმაცია უნდა შევინახო ცვლადში და შემდეგ ეს გამოვიყენო : 


2. ნაკადის გადაცემა ვიდეო ელემენტისთვის
მას შემდეგ, რაც ეკრანის გამოსახულებას "დავიჭერთ", ის სადმე უნდა გამოვაჩინოთ.

რა ხდება: შენს HTML-ში არსებულ <video> თეგს უნდა უთხრა, რომ მისი წყარო (Source) არის სწორედ ის "ნაკადი", რომელიც წინა ნაბიჯზე მიიღე.
ვიდეო ელემენტთან დაკავშირება
ვიდეო ელემენტს (<video>) აქვს სპეციალური თვისება, რომელსაც ჰქვია srcObject. ეს არის "მილსადენი", რომელიც იღებს ცოცხალ ნაკადს.

შეცდომა, რომელიც არ უნდა დაუშვა: არ გამოიყენო video.src = .... ეს მხოლოდ ფაილებისთვის ან ლინკებისთვისაა.

სწორი გზა: video.srcObject = mediaStream;
მნიშვნელოვანი მომენტი: ვიდეომ ავტომატურად უნდა დაიწყოს ჩვენება (play), როგორც კი მონაცემები მოვა.
- 3. ვიდეოს გაშვება - 
video.play();



4. შეცდომების მართვა (The Safety Net)
რატომ ვამატებთ: ეკრანის გაზიარება არის მომხმარებლის ნებაზე დამოკიდებული პროცესი. მან შეიძლება ნებისმიერ დროს დააჭიროს "Cancel"-ს.

დავალება: გამოიყენე try...catch ბლოკი getDisplayMedia-ს გარშემო.

ასახსნელი მასალა: თუ მომხმარებელი უარს იტყვის გაზიარებაზე, ბრაუზერი აგდებს "Error"-ს. ჩვენი კოდი არ უნდა "გატყდეს", არამედ თავაზიანად უნდა აუხსნას მომხმარებელს, რა მოხდა.

5. Picture-in-Picture-ის "ამოქმედება" (The Magic Button)
რატომ ვამატებთ: PiP-ის ჩართვა არ შეიძლება ავტომატურად, ის მხოლოდ მომხმარებლის კლიკზე მუშაობს.

მეთოდი: video.requestPictureInPicture().

ლოგიკა: ეს არის Promise, ამიტომ აქაც გვჭირდება await.

ოპტიმიზაცია: სანამ await სრულდება, ღილაკი უნდა იყოს disabled, რომ თავიდან ავიცილოთ ზედმეტი კლიკები (Spam protection).

6. რესურსების გასუფთავება (Resource Cleanup/Stop Sharing)
რატომ ვამატებთ: ეს არის ის, რაც განასხვავებს დამწყებს პროფესიონალისგან. თუ სტრიმს არ გავთიშავთ, ბრაუზერი გააგრძელებს მეხსიერების და ბატარეის ხარჯვას.

მოვლენა: leavepictureinpicture.

მოქმედება: captureStream.getTracks().forEach(track => track.stop()).

:  MediaStream შედგება ტრეკებისგან (ვიდეო, აუდიო) და თითოეულს ინდივიდუალური "გამორთვა" სჭირდება.

7. "Browser UI"-სთან სინქრონიზაცია (Edge Case)
რატომ ვამატებთ: მომხმარებელმა შეიძლება გაზიარება შეწყვიტოს არა ჩვენი ღილაკით, არამედ ბრაუზერის პატარა ლურჯი "Stop Sharing" ღილაკით.

ლოგიკა: ჩვენმა კოდმა უნდა "იცოდეს", რომ გაზიარება შეწყდა, რათა ეკრანიდან ვიდეო გააქროს ან PiP ფანჯარა დახუროს.

ივენთი: track.onended.
–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

https://github.com/tc39/proposals
ecmascript proposals

 
 navigator.mediaDevices       წვდომა კამერაზე/ეკრანზე. -    ბრაუზერის აპარატურასთან კავშირი

 srcObject          ვიდეოს წყაროს მიბმა.  -  ცოცხალი ნაკადის (Stream) მისაღებად
 
 requestPictureInPicture        ვიდეოს "ამოგლეჯა" -   PiP რეჟიმის გასააქტიურებლად
 
 getTracks()        სტრიმის დაშლა ნაწილებად    -     რესურსების სათითაოდ სამართავად
 
 track.stop()       ნაკადის საბოლოო გათიშვა  -   ბატარეის და უსაფრთხოების დასაცავად
